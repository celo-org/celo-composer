{
  "language": "Solidity",
  "sources": {
    "contracts/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract Token\n///+interfaces\n{\n    // Allow SafeMath functions to be called for all uint256 types\n    using SafeMath for uint256; \n\n    // Account used to deploy contract\n    address private contractOwner;         \n\n/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ASSET VALUE TRACKING: TOKEN  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/\n\n    string public name;\n    string public symbol;\n    uint256 public decimals;\n    \n    // Token balance for each address\n    mapping(address => uint256) balances;              \n\n    // Approval granted to transfer tokens by one address to another address                 \n    mapping (address => mapping (address => uint256)) internal allowed; \n\n    // Tokens currently in circulation (you'll need to update this if you create more tokens)\n    uint256 public total;                  \n\n    // Tokens created when contract was deployed                             \n    uint256 public initialSupply;         \n\n    // Multiplier to convert to smallest unit                              \n    uint256 public UNIT_MULTIPLIER;                                     \n\n    constructor()  \n    {\n        contractOwner = msg.sender;       \n\n/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ASSET VALUE TRACKING: TOKEN  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/\n\n        name = \"Token\";             \n        symbol = \"TKN\";           \n        decimals = 18;     \n\n        // // Multiplier to convert to smallest unit\n        UNIT_MULTIPLIER = 10 ** uint256(decimals); \n\n        uint256 supply = 1000;       \n        total = supply.mul(UNIT_MULTIPLIER);\n        initialSupply = total;\n\n        // // Assign entire initial supply to contract owner\n        balances[contractOwner] = total;    \n\n    }\n\n/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ASSET VALUE TRACKING: TOKEN  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/\n\n    // Fired when an account authorizes another account to spend tokens on its behalf\n\n    event Approval          \n                            (\n                                address indexed owner, \n                                address indexed spender, \n                                uint256 value\n                            );\n\n    // Fired when tokens are transferred from one account to another\n    event Transfer          \n                            (\n                                address indexed from, \n                                address indexed to, \n                                uint256 value\n                            );\n\n/*>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ASSET VALUE TRACKING: TOKEN  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/\n    /**\n    * @dev Total supply of tokens\n    */\n    function totalSupply() \n                            external \n                            view \n                            returns (uint256) \n    {\n        return total;\n    }\n\n    /**\n    * @dev Gets the balance of the calling address.\n    *\n    * @return An uint256 representing the amount owned by the calling address\n    */\n    function balance()\n                            public \n                            view \n                            returns (uint256) \n    {\n        return balanceOf(msg.sender);\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    *\n    * @param owner The address to query the balance of\n    * @return An uint256 representing the amount owned by the passed address\n    */\n    function balanceOf\n                            (\n                                address owner\n                            ) \n                            public \n                            view \n                            returns (uint256) \n    {\n        return balances[owner];\n    }\n\n    /**\n    * @dev Transfers token for a specified address\n    *\n    * @param to The address to transfer to.\n    * @param value The amount to be transferred.\n    * @return A bool indicating if the transfer was successful.\n    */\n    function transfer\n                            (\n                                address to, \n                                uint256 value\n                            ) \n                            public \n                            returns (bool) \n    {\n        require(to != address(0));\n        require(to != msg.sender);\n        require(value <= balanceOf(msg.sender));                                         \n\n        balances[msg.sender] = balances[msg.sender].sub(value);\n        balances[to] = balances[to].add(value);\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n    * @dev Transfers tokens from one address to another\n    *\n    * @param from address The address which you want to send tokens from\n    * @param to address The address which you want to transfer to\n    * @param value uint256 the amount of tokens to be transferred\n    * @return A bool indicating if the transfer was successful.\n    */\n    function transferFrom\n                            (\n                                address from, \n                                address to, \n                                uint256 value\n                            ) \n                            public \n                            returns (bool) \n    {\n        require(from != address(0));\n        require(value <= allowed[from][msg.sender]);\n        require(value <= balanceOf(from));                                         \n        require(to != address(0));\n        require(from != to);\n\n        balances[from] = balances[from].sub(value);\n        balances[to] = balances[to].add(value);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    /**\n    * @dev Checks the amount of tokens that an owner allowed to a spender.\n    *\n    * @param owner address The address which owns the funds.\n    * @param spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n    function allowance\n                            (\n                                address owner, \n                                address spender\n                            ) \n                            public \n                            view \n                            returns (uint256) \n    {\n        return allowed[owner][spender];\n    }\n\n    /**\n    * @dev Approves the passed address to spend the specified amount of tokens \n    *      on behalf of msg.sender.\n    *\n    * @param spender The address which will spend the funds.\n    * @param value The amount of tokens to be spent.\n    * @return A bool indicating success (always returns true)\n    */\n    function approve\n                            (\n                                address spender, \n                                uint256 value\n                            ) \n                            public \n                            returns (bool) \n    {\n        allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n    \n}   "
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}